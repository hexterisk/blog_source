<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="map[name:hexterisk]">
<meta name="description" content="Refer to this repository for solution scripts and the IPython Notebook pertaining to the explanations here.
Challenge 17: The CBC padding oracle Link
 This is the best-known attack on modern block-cipher cryptography.
Combine your padding code and your CBC code to write two functions.
The first function should select at random one of the following 10 strings:
MDAwMDAwTm93IHRoYXQgdGhlIHBhcnR5IGlzIGp1bXBpbmc=
MDAwMDAxV2l0aCB0aGUgYmFzcyBraWNrZWQgaW4gYW5kIHRoZSBWZWdhJ3MgYXJlIHB1bXBpbic=
MDAwMDAyUXVpY2sgdG8gdGhlIHBvaW50LCB0byB0aGUgcG9pbnQsIG5vIGZha2luZw==
MDAwMDAzQ29va2luZyBNQydzIGxpa2UgYSBwb3VuZCBvZiBiYWNvbg==
MDAwMDA0QnVybmluZyAnZW0sIGlmIHlvdSBhaW4ndCBxdWljayBhbmQgbmltYmxl
MDAwMDA1SSBnbyBjcmF6eSB3aGVuIEkgaGVhciBhIGN5bWJhbA==
MDAwMDA2QW5kIGEgaGlnaCBoYXQgd2l0aCBhIHNvdXBlZCB1cCB0ZW1wbw==
MDAwMDA3SSdtIG9uIGEgcm9sbCwgaXQncyB0aW1lIHRvIGdvIHNvbG8=
MDAwMDA4b2xsaW4nIGluIG15IGZpdmUgcG9pbnQgb2g=
MDAwMDA5aXRoIG15IHJhZy10b3AgZG93biBzbyBteSBoYWlyIGNhbiBibG93
&amp;hellip; generate a random AES key (which it should save for all future encryptions), pad the string out to the 16-byte AES block size and CBC-encrypt it under that key, providing the caller the ciphertext and IV." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="#252627" />
<link rel="canonical" href="https://hexterisk.github.io/blog/posts/2020/03/23/set-3/" />


    <title>
        
            Set 3: Pwn the world.  — A noob&#39;s attempt at blogging.
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="https://hexterisk.github.io/blog/main.min.d644853e3e89ab1ec568894a9a3df34b7e4e5bfd66060890b1e4297657fd91e8.css">




    <link rel="apple-touch-icon" sizes="180x180" href="https://hexterisk.github.io/blog/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://hexterisk.github.io/blog/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://hexterisk.github.io/blog/favicon-16x16.png">
    <link rel="manifest" href="https://hexterisk.github.io/blog/site.webmanifest">
    <link rel="mask-icon" href="https://hexterisk.github.io/blog/safari-pinned-tab.svg" color="#252627">
    <link rel="shortcut icon" href="https://hexterisk.github.io/blog/favicon.ico">
    <meta name="msapplication-TileColor" content="#252627">
    <meta name="theme-color" content="#252627">

<meta itemprop="name" content="Set 3">
<meta itemprop="description" content="Refer to this repository for solution scripts and the IPython Notebook pertaining to the explanations here.
Challenge 17: The CBC padding oracle Link
 This is the best-known attack on modern block-cipher cryptography.
Combine your padding code and your CBC code to write two functions.
The first function should select at random one of the following 10 strings:
MDAwMDAwTm93IHRoYXQgdGhlIHBhcnR5IGlzIGp1bXBpbmc=
MDAwMDAxV2l0aCB0aGUgYmFzcyBraWNrZWQgaW4gYW5kIHRoZSBWZWdhJ3MgYXJlIHB1bXBpbic=
MDAwMDAyUXVpY2sgdG8gdGhlIHBvaW50LCB0byB0aGUgcG9pbnQsIG5vIGZha2luZw==
MDAwMDAzQ29va2luZyBNQydzIGxpa2UgYSBwb3VuZCBvZiBiYWNvbg==
MDAwMDA0QnVybmluZyAnZW0sIGlmIHlvdSBhaW4ndCBxdWljayBhbmQgbmltYmxl
MDAwMDA1SSBnbyBjcmF6eSB3aGVuIEkgaGVhciBhIGN5bWJhbA==
MDAwMDA2QW5kIGEgaGlnaCBoYXQgd2l0aCBhIHNvdXBlZCB1cCB0ZW1wbw==
MDAwMDA3SSdtIG9uIGEgcm9sbCwgaXQncyB0aW1lIHRvIGdvIHNvbG8=
MDAwMDA4b2xsaW4nIGluIG15IGZpdmUgcG9pbnQgb2g=
MDAwMDA5aXRoIG15IHJhZy10b3AgZG93biBzbyBteSBoYWlyIGNhbiBibG93
&hellip; generate a random AES key (which it should save for all future encryptions), pad the string out to the 16-byte AES block size and CBC-encrypt it under that key, providing the caller the ciphertext and IV."><meta itemprop="datePublished" content="2020-03-23T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-03-23T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="4883"><meta itemprop="image" content="https://hexterisk.github.io/blog"/>
<meta itemprop="keywords" content="Matasano,cryptography,AES,ECB,CBC,CTR,xor,MT19937,Mersenne,PRNG,seed," /><meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://hexterisk.github.io/blog"/>

<meta name="twitter:title" content="Set 3"/>
<meta name="twitter:description" content="Refer to this repository for solution scripts and the IPython Notebook pertaining to the explanations here.
Challenge 17: The CBC padding oracle Link
 This is the best-known attack on modern block-cipher cryptography.
Combine your padding code and your CBC code to write two functions.
The first function should select at random one of the following 10 strings:
MDAwMDAwTm93IHRoYXQgdGhlIHBhcnR5IGlzIGp1bXBpbmc=
MDAwMDAxV2l0aCB0aGUgYmFzcyBraWNrZWQgaW4gYW5kIHRoZSBWZWdhJ3MgYXJlIHB1bXBpbic=
MDAwMDAyUXVpY2sgdG8gdGhlIHBvaW50LCB0byB0aGUgcG9pbnQsIG5vIGZha2luZw==
MDAwMDAzQ29va2luZyBNQydzIGxpa2UgYSBwb3VuZCBvZiBiYWNvbg==
MDAwMDA0QnVybmluZyAnZW0sIGlmIHlvdSBhaW4ndCBxdWljayBhbmQgbmltYmxl
MDAwMDA1SSBnbyBjcmF6eSB3aGVuIEkgaGVhciBhIGN5bWJhbA==
MDAwMDA2QW5kIGEgaGlnaCBoYXQgd2l0aCBhIHNvdXBlZCB1cCB0ZW1wbw==
MDAwMDA3SSdtIG9uIGEgcm9sbCwgaXQncyB0aW1lIHRvIGdvIHNvbG8=
MDAwMDA4b2xsaW4nIGluIG15IGZpdmUgcG9pbnQgb2g=
MDAwMDA5aXRoIG15IHJhZy10b3AgZG93biBzbyBteSBoYWlyIGNhbiBibG93
&hellip; generate a random AES key (which it should save for all future encryptions), pad the string out to the 16-byte AES block size and CBC-encrypt it under that key, providing the caller the ciphertext and IV."/>



    <meta property="article:section" content="Cryptopals" />



    <meta property="article:published_time" content="2020-03-23 00:00:00 &#43;0000 UTC" />








    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://hexterisk.github.io/blog/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$cd ~/</span>
            <span class="logo__cursor" style=""></span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://hexterisk.github.io/blog/about/">About</a></li><li><a href="https://hexterisk.github.io/blog/posts/">Posts</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>23 minutes

            

            </p>
        </div>

        <article>
            <h1 class="post-title">
                <a href="https://hexterisk.github.io/blog/posts/2020/03/23/set-3/">Set 3</a>
            </h1>

            

            <div class="post-content">
                <p>Refer to this <a href="https://github.com/hexterisk/cryptopals-solutions">repository</a> for solution scripts and the IPython Notebook pertaining to the explanations here.</p>
<h3 id="challenge-17-the-cbc-padding-oracle">Challenge 17: The CBC padding oracle</h3>
<p><a href="https://cryptopals.com/sets/3/challenges/17">Link</a></p>
<blockquote>
<p>This is the best-known attack on modern block-cipher cryptography.<br>
Combine your padding code and your CBC code to write two functions.<br>
The first function should select at random one of the following 10 strings:<br>
<strong>MDAwMDAwTm93IHRoYXQgdGhlIHBhcnR5IGlzIGp1bXBpbmc=</strong><br>
<strong>MDAwMDAxV2l0aCB0aGUgYmFzcyBraWNrZWQgaW4gYW5kIHRoZSBWZWdhJ3MgYXJlIHB1bXBpbic=</strong><br>
<strong>MDAwMDAyUXVpY2sgdG8gdGhlIHBvaW50LCB0byB0aGUgcG9pbnQsIG5vIGZha2luZw==</strong><br>
<strong>MDAwMDAzQ29va2luZyBNQydzIGxpa2UgYSBwb3VuZCBvZiBiYWNvbg==</strong><br>
<strong>MDAwMDA0QnVybmluZyAnZW0sIGlmIHlvdSBhaW4ndCBxdWljayBhbmQgbmltYmxl</strong><br>
<strong>MDAwMDA1SSBnbyBjcmF6eSB3aGVuIEkgaGVhciBhIGN5bWJhbA==</strong><br>
<strong>MDAwMDA2QW5kIGEgaGlnaCBoYXQgd2l0aCBhIHNvdXBlZCB1cCB0ZW1wbw==</strong><br>
<strong>MDAwMDA3SSdtIG9uIGEgcm9sbCwgaXQncyB0aW1lIHRvIGdvIHNvbG8=</strong><br>
<strong>MDAwMDA4b2xsaW4nIGluIG15IGZpdmUgcG9pbnQgb2g=</strong><br>
<strong>MDAwMDA5aXRoIG15IHJhZy10b3AgZG93biBzbyBteSBoYWlyIGNhbiBibG93</strong><br>
&hellip; generate a random AES key (which it should save for all future encryptions), pad the string out to the 16-byte AES block size and CBC-encrypt it under that key, providing the caller the ciphertext and IV.<br>
The second function should consume the ciphertext produced by the first function, decrypt it, check its padding, and return true or false depending on whether the padding is valid.<br>
It turns out that it&rsquo;s possible to decrypt the ciphertexts provided by the first function.<br>
The decryption here depends on a side-channel leak by the decryption function. The leak is the error message that the padding is valid or not.<br>
You can find 100 web pages on how this attack works, so I won&rsquo;t re-explain it. What I&rsquo;ll say is this:<br>
The fundamental insight behind this attack is that the byte 01h is valid padding, and occur in 1/256 trials of &ldquo;randomized&rdquo; plaintexts produced by decrypting a tampered ciphertext.<br>
02h in isolation is not valid padding.<br>
02h 02h is valid padding, but is much less likely to occur randomly than 01h.<br>
03h 03h 03h is even less likely.<br>
So you can assume that if you corrupt a decryption AND it had valid padding, you know what that padding byte is.<br>
It is easy to get tripped up on the fact that CBC plaintexts are &ldquo;padded&rdquo;. Padding oracles have nothing to do with the actual padding on a CBC plaintext. It&rsquo;s an attack that targets a specific bit of code that handles decryption. You can mount a padding oracle on any CBC block, whether it&rsquo;s padded or not.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Imports</span>
<span style="color:#f92672">import</span> os
<span style="color:#f92672">import</span> base64
<span style="color:#f92672">import</span> random
<span style="color:#f92672">from</span> Crypto.Cipher <span style="color:#f92672">import</span> AES

<span style="color:#75715e"># Given</span>
b64_strings <span style="color:#f92672">=</span> [
    <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;MDAwMDAwTm93IHRoYXQgdGhlIHBhcnR5IGlzIGp1bXBpbmc=&#39;</span>,
    <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;MDAwMDAxV2l0aCB0aGUgYmFzcyBraWNrZWQgaW4gYW5kIHRoZSBWZWdhJ3MgYXJlIHB1bXBpbic=&#39;</span>,
    <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;MDAwMDAyUXVpY2sgdG8gdGhlIHBvaW50LCB0byB0aGUgcG9pbnQsIG5vIGZha2luZw==&#39;</span>,
    <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;MDAwMDAzQ29va2luZyBNQydzIGxpa2UgYSBwb3VuZCBvZiBiYWNvbg==&#39;</span>,
    <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;MDAwMDA0QnVybmluZyAnZW0sIGlmIHlvdSBhaW4ndCBxdWljayBhbmQgbmltYmxl&#39;</span>,
    <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;MDAwMDA1SSBnbyBjcmF6eSB3aGVuIEkgaGVhciBhIGN5bWJhbA==&#39;</span>,
    <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;MDAwMDA2QW5kIGEgaGlnaCBoYXQgd2l0aCBhIHNvdXBlZCB1cCB0ZW1wbw==&#39;</span>,
    <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;MDAwMDA3SSdtIG9uIGEgcm9sbCwgaXQncyB0aW1lIHRvIGdvIHNvbG8=&#39;</span>,
    <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;MDAwMDA4b2xsaW4nIGluIG15IGZpdmUgcG9pbnQgb2g=&#39;</span>,
    <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;MDAwMDA5aXRoIG15IHJhZy10b3AgZG93biBzbyBteSBoYWlyIGNhbiBibG93&#39;</span>,
]
</code></pre></div><p>The first function:</p>
<ul>
<li>Selects a random base64 encoded given string.</li>
<li>Pad the string to block size.</li>
<li>CBC encrypts the chosen string under the key.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">encryptor</span>(IV: bytes, key: bytes) <span style="color:#f92672">-&gt;</span> (bytes, bytes):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Chose a random base64 encoded string and encrypt via AES CBC Mode.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    index <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">0</span>, len(b64_strings)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
    selected_string <span style="color:#f92672">=</span> b64_strings[index]
    ciphertext <span style="color:#f92672">=</span> AES_CBC_encrypt(selected_string, IV, key)
    <span style="color:#66d9ef">return</span> selected_string, ciphertext
</code></pre></div><p>The second function:</p>
<ul>
<li>Decrypts the given ciphertext.</li>
<li>Verify the decrypted string&rsquo;s padding.</li>
<li>Returns true or false based on validity of padding.</li>
</ul>
<p>NOTE: The specifications of this function are to be paid attention to, specifically the last one. The attack is only possible if the oracle gives a feedback on the padding of the plaintext encrypted being valid.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decryptor</span>(ciphertext: bytes, IV: bytes, key: bytes) <span style="color:#f92672">-&gt;</span> bool:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Decrypt the given ciphertext via AES CBC Mode and check if padding is valid.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    plaintext <span style="color:#f92672">=</span> AES_CBC_decrypt(ciphertext, IV, key)
    <span style="color:#66d9ef">if</span> PKCS7_padded(plaintext):
        <span style="color:#66d9ef">return</span> True
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">return</span> False
</code></pre></div><p><img src="https://hexterisk.github.io/blog/Cryptopals_Set_3/image.png" alt="">
<em>AES CBC Decryption.</em></p>
<p>The philosophy for the padding attack stems from the design of the CBC encryption mechanism. The ciphertext from the previous block is xored with the intermediate state of the next block formed during it&rsquo;s decryption. Since we have control over the ciphertext, maybe we can manipulate the blocks in some way into giving us some sort of indication towards it&rsquo;s effectiveness.</p>
<p><img src="https://hexterisk.github.io/blog/Cryptopals_Set_3/1_image.png" alt="">
<em>Xoring the bytes to get valid padding.</em></p>
<p>The idea of the padding oracle attack is as follows:</p>
<p>We want to modify the last byte <code>X</code> of the second-to-last block so that the CBC decryption of the last block which has <code>?</code> as its content yields <code>0x01</code> instead. This of course works because CBC decrypts as: </p>
<p>Mⁱ = Decrypt(Cⁱ) ⊕ Cⁱᐨ¹</p>
<p>Finding the right <code>X</code> is achieved by querying all 256 values to the padding oracle to which you should only get one positive response (when you hit the correct plaintext guess or accidently hit a longer padding).</p>
<p>When we&rsquo;ve guessed this byte and move on to the next byte, the byte in focus can be deciphered the same way, while the byte we already discovered(the last byte of the block) can be xored with a value that converts the last byte of the plaintext in line with the requirement (say, we decipher the last byte as ‘A’, and since it&rsquo;s the second last byte in focus, we have to convert it into ‘\x02’. We simply put in the last byte of the previous block as something that would give us the plaintext&rsquo;s last byte&rsquo;s value to be ‘\x02’ after all the xoring.</p>
<p>The execution of the attack is in two parts, the first part being the modification of the previous cipher block and the second being the brute forcing, and are complimentary to each other.</p>
<p>Part 1:</p>
<p>We create a function to modify the (i-1)th cipherblock according to what the value of the padding byte has to be. The block to be modified is provided(treated as the IV) along with the plaintext already deciphered, padding of length we&rsquo;re at(gives away the index of the byte we&rsquo;re guessing, since we have to get the padding valid for the number of bytes guessed correctly already + 1) and of course, the byte we think is the one for us(the guessed byte).</p>
<p>The block is modified as follows:</p>
<ol>
<li>The IV remains as is until (length of the block - padding length). This is because these bytes aren&rsquo;t the focus yet, and could have any value for that matter.</li>
<li>We then add our guessed byte. This is the one we think will get us the right padding.</li>
<li>Followed by appending the bytes that would definitely generate the bytes corresponding to the padding length, since a block requiring a padding of N bytes is padding with the byte ‘\xN' ( following the norms of PKCS7).</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">modify_block</span>(IV: bytes, guessed_byte: bytes, padding_len: int, found_plaintext: bytes) <span style="color:#f92672">-&gt;</span> bytes:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Creates a forced block of the ciphertext, ideally to be given as IV to decrypt the following block.
</span><span style="color:#e6db74">    The forced IV will be used for the attack on the padding oracle CBC encryption.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    
    block_size <span style="color:#f92672">=</span> len(IV)

    <span style="color:#75715e"># Get the index of the first character of the padding.</span>
    index_of_forced_char <span style="color:#f92672">=</span> len(IV) <span style="color:#f92672">-</span> padding_len

    <span style="color:#75715e"># Using the guessed byte given as input, try to force the first character of the</span>
    <span style="color:#75715e"># padding to be equal to the length of the padding itself.</span>
    forced_character <span style="color:#f92672">=</span> IV[index_of_forced_char] <span style="color:#f92672">^</span> guessed_byte <span style="color:#f92672">^</span> padding_len

    <span style="color:#75715e"># Form the forced ciphertext by adding to it the forced character...</span>
    output <span style="color:#f92672">=</span> IV[:index_of_forced_char] <span style="color:#f92672">+</span> bytes([forced_character])

    <span style="color:#75715e"># ...and the characters that were forced before (for which we already know the plaintext).</span>
    m <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(block_size <span style="color:#f92672">-</span> padding_len <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, block_size):

        <span style="color:#75715e"># Force each of the following characters of the IV so that the matching characters in</span>
        <span style="color:#75715e"># the following block will be decrypted to &#34;padding_len&#34;.</span>
        forced_character <span style="color:#f92672">=</span> IV[k] <span style="color:#f92672">^</span> ord(found_plaintext[m]) <span style="color:#f92672">^</span> padding_len
        output <span style="color:#f92672">+=</span> bytes([forced_character])
        m <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

    <span style="color:#66d9ef">return</span> output
</code></pre></div><p>Part 2:</p>
<p>The exploiting function goes over the ciphertext, block by block. During the processing of each block, it goes over every byte. This happens with the aid of the <code>modify_block</code> function we saw earlier. </p>
<p>We append the IV to the ciphertext and start verifying the padding of the ciphertext by working with only two blocks at a time, the first one taking place of the (i-1)th block(treated as an IV since only two blocks exist), and the second one taking the place of the ith block(the one we&rsquo;re trying to decrypt and verify the padding for). The first block is modified so as to yield a valid padding when the next block is decrypted. Since we do not know against which byte would obtain the valid padding, we resort to the brute force approach. We go over all 256 values for the byte in focus, modify the block every time and check if the decrypted plaintext has a valid padding. The moment it does, bingo. That&rsquo;s our byte. We then move onto the next byte, and then the next block, and then gradually, we have the whole plaintext deciphered right in front of our eyes.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">cbc_padding_attack</span>(ciphertext: bytes, IV: bytes, key: bytes, decryptor: callable) <span style="color:#f92672">-&gt;</span> bytes:

    block_size <span style="color:#f92672">=</span> len(IV)
    
    <span style="color:#75715e"># Create ciphertext blocks, with IV prepended to the ciphertexts.</span>
    <span style="color:#75715e"># The prepended IV enables us to decrypt the first block of ciphertext.</span>
    plaintext <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
    num_blocks <span style="color:#f92672">=</span> len(ciphertext)<span style="color:#f92672">//</span>block_size
    ciphertext_blocks <span style="color:#f92672">=</span> [IV] <span style="color:#f92672">+</span> [ciphertext[i:i<span style="color:#f92672">+</span>block_size] <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(ciphertext), block_size)]
    
    <span style="color:#75715e"># This loop goes over the cipher blocks.</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, num_blocks<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
        plain_block <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
        base_block <span style="color:#f92672">=</span> ciphertext_blocks[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] 
        target_block <span style="color:#f92672">=</span> ciphertext_blocks[i]
                
        <span style="color:#75715e"># This loop goes over every byte in a block.</span>
        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, block_size<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            possible_last_bytes <span style="color:#f92672">=</span> []
            <span style="color:#75715e"># This loop goes over all possible values for a byte.</span>
            <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">256</span>):
                
                mod_block <span style="color:#f92672">=</span> modify_block(base_block, k, j, plain_block)                
                check <span style="color:#f92672">=</span> decryptor(target_block, mod_block, key)
                <span style="color:#75715e"># Make a list of all values that satisfy the padding.</span>
                <span style="color:#66d9ef">if</span> check <span style="color:#f92672">==</span> True:
                    possible_last_bytes <span style="color:#f92672">+=</span> bytes([k])
                
            <span style="color:#75715e"># If more than one possible bytes have been found, then verify their validity by checking the next byte.</span>
            <span style="color:#66d9ef">if</span> len(possible_last_bytes) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>:
                <span style="color:#66d9ef">for</span> byte <span style="color:#f92672">in</span> possible_last_bytes:
                    <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">256</span>):
                        
                        mod_block <span style="color:#f92672">=</span> modify_block(base_block, k, j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, chr(byte)<span style="color:#f92672">+</span>plain_block)                
                        
                        check <span style="color:#f92672">=</span> decryptor(target_block, mod_block, key)
                        <span style="color:#66d9ef">if</span> check <span style="color:#f92672">==</span> True:
                            possible_last_bytes <span style="color:#f92672">=</span> [byte]
                            <span style="color:#66d9ef">break</span>
            <span style="color:#75715e"># Append the decrypted byte to the plain block.                </span>
            plain_block <span style="color:#f92672">=</span> chr(possible_last_bytes[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">+</span> plain_block
        <span style="color:#75715e"># Append the decrypted block to plaintext.</span>
        plaintext <span style="color:#f92672">+=</span> plain_block
    
    <span style="color:#66d9ef">return</span> PKCS7_unpad(plaintext<span style="color:#f92672">.</span>encode())
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">keysize <span style="color:#f92672">=</span> AES<span style="color:#f92672">.</span>block_size
random_key <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>urandom(keysize)
IV <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>urandom(keysize)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">selected_string, ciphertext <span style="color:#f92672">=</span> encryptor(IV, random_key)
plaintext <span style="color:#f92672">=</span> cbc_padding_attack(ciphertext, IV, random_key, decryptor)
result <span style="color:#f92672">=</span> base64<span style="color:#f92672">.</span>b64decode(plaintext)<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#34;utf-8&#34;</span>)
result
</code></pre></div><p><code>&quot;000001With the bass kicked in and the Vega's are pumpin'&quot;</code></p>


<div style="border:1px solid #c3e6cb;padding:.75rem 3rem;border-radius:.5rem;font-weight:bold;text-align: center;background-color:#d4edda;color:#155724;border-color:#c3e6cb;">Completed</div>


<h3 id="challenge-18-implement-ctr-the-stream-cipher-mode">Challenge 18: Implement CTR, the stream cipher mode</h3>
<p><a href="https://cryptopals.com/sets/3/challenges/18">Link</a></p>
<blockquote>
<p>The string:<br>
<strong>L77na/nrFsKvynd6HzOoG7GHTLXsTVu9qvY/2syLXzhPweyyMTJULu/6/kXX0KSvoOLSFQ==</strong> &hellip; decrypts to something approximating English in CTR mode, which is an AES block cipher mode that turns AES into a stream cipher, with the following parameters:<br>
** key=YELLOW SUBMARINE<br>
nonce=0<br>
format=64 bit unsigned little endian nonce,<br>
64 bit little endian block count (byte count / 16)<br>
** CTR mode is very simple.<br>
Instead of encrypting the plaintext, CTR mode encrypts a running counter, producing a 16 byte block of keystream, which is XOR&rsquo;d against the plaintext.<br>
For instance, for the first 16 bytes of a message with these parameters:<br>
<strong>keystream = AES(&ldquo;YELLOW SUBMARINE&rdquo;,</strong><br>
<strong>&quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;)</strong><br>
&hellip; for the next 16 bytes:<br>
<strong>keystream = AES(&ldquo;YELLOW SUBMARINE&rdquo;, &ldquo;\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00&rdquo;)</strong><br>
&hellip; and then:<br>
<strong>keystream = AES(&ldquo;YELLOW SUBMARINE&rdquo;,</strong><br>
<strong>&quot;\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00&quot;)</strong><br>
CTR mode does not require padding; when you run out of plaintext, you just stop XOR&rsquo;ing keystream and stop generating keystream.<br>
Decryption is identical to encryption. Generate the same keystream, XOR, and recover the plaintext.<br>
Decrypt the string at the top of this function, then use your CTR function to encrypt and decrypt other things.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Imports</span>
<span style="color:#f92672">import</span> base64

<span style="color:#75715e"># Given</span>
b64_string <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;L77na/nrFsKvynd6HzOoG7GHTLXsTVu9qvY/2syLXzhPweyyMTJULu/6/kXX0KSvoOLSFQ==&#34;</span>
key <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;YELLOW SUBMARINE&#34;</span>
nonce <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</code></pre></div><p>The third AES Mode is the <strong>CTR</strong> (<strong>Counter</strong>) Mode. It uses a keystream to encrypt/decrypt, turning block cipher into a stream cipher. </p>
<p><img src="https://hexterisk.github.io/blog/Cryptopals_Set_3/5_image.png" alt="">
<em>Keystream blocks being generated.</em></p>
<p>This keystream is generated block at a time, by appending a nonce value, and a counter that is being incremented at every call to it. The counter can be any function which produces a sequence which is guaranteed not to repeat for a long time, although an actual increment-by-one counter is the simplest and most popular.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">CTR_keystream_generator</span>(key: bytes, nonce: int) <span style="color:#f92672">-&gt;</span> bytes:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Generates keystream based on given key and nonce.
</span><span style="color:#e6db74">    Uses AES ECB Mode to encrypt the nonce+counter block.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#75715e"># 8 byte because format says 64bit.</span>
    nonce_bytes <span style="color:#f92672">=</span> nonce<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;little&#34;</span>)
    
    <span style="color:#66d9ef">while</span> True:
        counter_bytes <span style="color:#f92672">=</span> counter<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;little&#34;</span>)
        <span style="color:#75715e"># Keep getting 16byte block from the encryption function.</span>
        keystream_block <span style="color:#f92672">=</span> AES_ECB_encrypt(nonce_bytes <span style="color:#f92672">+</span> counter_bytes, key)
        <span style="color:#66d9ef">yield</span> <span style="color:#f92672">from</span> keystream_block
        counter <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</code></pre></div><p><img src="https://hexterisk.github.io/blog/Cryptopals_Set_3/2_image.png" alt="">
<em>AES CTR Encryption.</em></p>
<p>The encryption process involves encrypting the keystream block with a different block cipher encrypting technique and xoring it with plaintext to generate ciphertext.</p>
<p><img src="https://hexterisk.github.io/blog/Cryptopals_Set_3/3_image.png" alt="">
<em>AES CTR Decryption.</em></p>
<p>The decryption process can be stated as a mirror of the encryption process. It again encrypts the keystream block with the same block cipher encrypting technique as was used during encryption, and then xoring the ciphertext with it to receive the plaintext back.</p>
<p>It&rsquo;s clearly a play on one of the crucial properties of the xor operation: it&rsquo;s reversible.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">CTR</span>(string: bytes, key: bytes, nonce: int) <span style="color:#f92672">-&gt;</span> bytes:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Encrypts a plaintext with AES CTR Mode.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#75715e"># Generate the keystream based on key and nonce.</span>
    keystream <span style="color:#f92672">=</span> CTR_keystream_generator(key, nonce)
    
    <span style="color:#66d9ef">if</span> len(string) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">return</span> xor_bytes(string, keystream)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">decoded_string <span style="color:#f92672">=</span> base64<span style="color:#f92672">.</span>b64decode(b64_string)
byte_text <span style="color:#f92672">=</span> CTR(decoded_string, key<span style="color:#f92672">.</span>encode(), <span style="color:#ae81ff">0</span>)
byte_text<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#34;utf-8&#34;</span>)
</code></pre></div><p><code>&quot;Yo, VIP Let's kick it Ice, Ice, baby Ice, Ice, baby &quot;</code></p>


<div style="border:1px solid #c3e6cb;padding:.75rem 3rem;border-radius:.5rem;font-weight:bold;text-align: center;background-color:#d4edda;color:#155724;border-color:#c3e6cb;">Completed</div>


<p>I came up with the solution for #19 involving scoring texts based on letter frequency, and it turned out to be the solution for #20 too.</p>
<h3 id="challenge-19-break-fixed-nonce-ctr-mode-using-substitutions">Challenge 19: Break fixed-nonce CTR mode using substitutions</h3>
<p><a href="https://cryptopals.com/sets/3/challenges/19">Link</a></p>
<blockquote>
<p>Take your CTR encrypt/decrypt function and fix its nonce value to 0. Generate a random AES key.<br>
In successive encryptions (not in one big running CTR stream), encrypt each line of the base64 decodes of the following, producing multiple independent ciphertexts:<br>
<strong>SSBoYXZlIG1ldCB0aGVtIGF0IGNsb3NlIG9mIGRheQ==</strong><br>
<strong>Q29taW5nIHdpdGggdml2aWQgZmFjZXM=</strong><br>
<strong>RnJvbSBjb3VudGVyIG9yIGRlc2sgYW1vbmcgZ3JleQ==</strong><br>
<strong>RWlnaHRlZW50aC1jZW50dXJ5IGhvdXNlcy4=</strong><br>
<strong>SSBoYXZlIHBhc3NlZCB3aXRoIGEgbm9kIG9mIHRoZSBoZWFk</strong><br>
<strong>T3IgcG9saXRlIG1lYW5pbmdsZXNzIHdvcmRzLA==</strong><br>
<strong>T3IgaGF2ZSBsaW5nZXJlZCBhd2hpbGUgYW5kIHNhaWQ=</strong><br>
<strong>UG9saXRlIG1lYW5pbmdsZXNzIHdvcmRzLA==</strong><br>
<strong>QW5kIHRob3VnaHQgYmVmb3JlIEkgaGFkIGRvbmU=</strong><br>
<strong>T2YgYSBtb2NraW5nIHRhbGUgb3IgYSBnaWJl</strong><br>
<strong>VG8gcGxlYXNlIGEgY29tcGFuaW9u</strong><br>
<strong>QXJvdW5kIHRoZSBmaXJlIGF0IHRoZSBjbHViLA==</strong><br>
<strong>QmVpbmcgY2VydGFpbiB0aGF0IHRoZXkgYW5kIEk=</strong><br>
<strong>QnV0IGxpdmVkIHdoZXJlIG1vdGxleSBpcyB3b3JuOg==</strong><br>
<strong>QWxsIGNoYW5nZWQsIGNoYW5nZWQgdXR0ZXJseTo=</strong><br>
<strong>QSB0ZXJyaWJsZSBiZWF1dHkgaXMgYm9ybi4=</strong><br>
<strong>VGhhdCB3b21hbidzIGRheXMgd2VyZSBzcGVudA==</strong><br>
<strong>SW4gaWdub3JhbnQgZ29vZCB3aWxsLA==</strong><br>
<strong>SGVyIG5pZ2h0cyBpbiBhcmd1bWVudA==</strong><br>
<strong>VW50aWwgaGVyIHZvaWNlIGdyZXcgc2hyaWxsLg==</strong><br>
<strong>V2hhdCB2b2ljZSBtb3JlIHN3ZWV0IHRoYW4gaGVycw==</strong><br>
<strong>V2hlbiB5b3VuZyBhbmQgYmVhdXRpZnVsLA==</strong><br>
<strong>U2hlIHJvZGUgdG8gaGFycmllcnM/</strong><br>
<strong>VGhpcyBtYW4gaGFkIGtlcHQgYSBzY2hvb2w=</strong><br>
<strong>QW5kIHJvZGUgb3VyIHdpbmdlZCBob3JzZS4=</strong><br>
<strong>VGhpcyBvdGhlciBoaXMgaGVscGVyIGFuZCBmcmllbmQ=</strong><br>
<strong>V2FzIGNvbWluZyBpbnRvIGhpcyBmb3JjZTs=</strong><br>
<strong>SGUgbWlnaHQgaGF2ZSB3b24gZmFtZSBpbiB0aGUgZW5kLA==</strong><br>
<strong>U28gc2Vuc2l0aXZlIGhpcyBuYXR1cmUgc2VlbWVkLA==</strong><br>
<strong>U28gZGFyaW5nIGFuZCBzd2VldCBoaXMgdGhvdWdodC4=</strong><br>
<strong>VGhpcyBvdGhlciBtYW4gSSBoYWQgZHJlYW1lZA==</strong><br>
<strong>QSBkcnVua2VuLCB2YWluLWdsb3Jpb3VzIGxvdXQu</strong><br>
<strong>SGUgaGFkIGRvbmUgbW9zdCBiaXR0ZXIgd3Jvbmc=</strong><br>
<strong>VG8gc29tZSB3aG8gYXJlIG5lYXIgbXkgaGVhcnQs</strong><br>
<strong>WWV0IEkgbnVtYmVyIGhpbSBpbiB0aGUgc29uZzs=</strong><br>
<strong>SGUsIHRvbywgaGFzIHJlc2lnbmVkIGhpcyBwYXJ0</strong><br>
<strong>SW4gdGhlIGNhc3VhbCBjb21lZHk7</strong><br>
<strong>SGUsIHRvbywgaGFzIGJlZW4gY2hhbmdlZCBpbiBoaXMgdHVybiw=</strong><br>
<strong>VHJhbnNmb3JtZWQgdXR0ZXJseTo=</strong><br>
<strong>QSB0ZXJyaWJsZSBiZWF1dHkgaXMgYm9ybi4=</strong><br>
(This should produce 40 short CTR-encrypted ciphertexts).<br>
Because the CTR nonce wasn&rsquo;t randomized for each encryption, each ciphertext has been encrypted against the same keystream. This is very bad.<br>
Understanding that, like most stream ciphers (including RC4, and obviously any block cipher run in CTR mode), the actual &ldquo;encryption&rdquo; of a byte of data boils down to a single XOR operation, it should be plain that:<br>
<strong>CIPHERTEXT-BYTE XOR PLAINTEXT-BYTE = KEYSTREAM-BYTE</strong><br>
And since the keystream is the same for every ciphertext:<br>
<strong>CIPHERTEXT-BYTE XOR KEYSTREAM-BYTE = PLAINTEXT-BYTE (ie, &ldquo;you don&rsquo;t say!&quot;)</strong><br>
Attack this cryptosystem piecemeal: guess letters, use expected English language frequence to validate guesses, catch common English trigrams, and so on.</p>
</blockquote>
<p>and</p>
<h3 id="challenge-20-break-fixed-nonce-ctr-statistically">Challenge 20: Break fixed-nonce CTR statistically</h3>
<p><a href="https://cryptopals.com/sets/3/challenges/20">Link</a></p>
<blockquote>
<p><a href="https://cryptopals.com/static/challenge-data/20.txt">In this file</a> find a similar set of Base64&rsquo;d plaintext. Do with them exactly what you did with the first, but solve the problem differently.<br>
Instead of making spot guesses at to known plaintext, treat the collection of ciphertexts the same way you would repeating-key XOR.<br>
Obviously, CTR encryption appears different from repeated-key XOR, but with a fixed nonce they are effectively the same thing.<br>
To exploit this: take your collection of ciphertexts and truncate them to a common length (the length of the smallest ciphertext will work).<br>
Solve the resulting concatenation of ciphertexts as if for repeating- key XOR, with a key size of the length of the ciphertext you XOR&rsquo;d.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Imports</span>
<span style="color:#f92672">import</span> os
<span style="color:#f92672">import</span> base64

<span style="color:#75715e"># Given</span>
b64_strings <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;20.txt&#34;</span>)<span style="color:#f92672">.</span>readlines()
nonce <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

random_key <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>urandom(<span style="color:#ae81ff">16</span>)
decoded_strings <span style="color:#f92672">=</span> [base64<span style="color:#f92672">.</span>b64decode(line<span style="color:#f92672">.</span>strip()) <span style="color:#66d9ef">for</span> line <span style="color:#f92672">in</span> b64_strings]
ciphertext_list <span style="color:#f92672">=</span> [CTR(string, random_key, nonce) <span style="color:#66d9ef">for</span> string <span style="color:#f92672">in</span> decoded_strings]
min_ciphertext_length <span style="color:#f92672">=</span> min(map(len, ciphertext_list))
</code></pre></div><p>The thing to note here is the fact that the same keystream is used to encrypt all the strings provided in the file. Therefore, if we stack all the ciphertext strings one on top of the other, it becomes clear that all the Nth byte in each of the ciphertext strings have been encrypted by the Nth byte of the keystream. Therefore, it can be considered to be a case of single-byte xor.</p>
<p>The function extends the idea from #6: create blocks of the bytes at same indices from all the ciphertext strings, and then solve them based on the score from letters.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">columns <span style="color:#f92672">=</span> []
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(min_ciphertext_length):
    line <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
    <span style="color:#66d9ef">for</span> cipher <span style="color:#f92672">in</span> ciphertext_list:
        line <span style="color:#f92672">+=</span> cipher[i]<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;big&#34;</span>)
    result <span style="color:#f92672">=</span> single_byte_xor_score(line)
    columns<span style="color:#f92672">.</span>append(result[<span style="color:#e6db74">&#34;message&#34;</span>])

message <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(min_ciphertext_length):
    <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> columns:
        message <span style="color:#f92672">+=</span> c[i]

message
</code></pre></div><p><code>'N\'m rated &quot;R&quot;...this is a warning, ya better void / PDuz I came back to attack others in spite- / Strike lEut don\'t be afraid in the dark, in a park / Not a sc^a tremble like a alcoholic, muscles tighten up / WhaTuddenly you feel like your in a horror flick / You gJusic\'s the clue, when I come your warned / ApocalypsOaven\'t you ever heard of a MC-murderer? / This is thCeath wish, so come on, step to this / Hysterical ideAriday the thirteenth, walking down Elm Street / You Shis is off limits, so your visions are blurry / All Serror in the styles, never error-files / Indeed I\'m Aor those that oppose to be level or next to this / IPorse than a nightmare, you don\'t have to sleep a winAlashbacks interfere, ya start to hear: / The R-A-K-IShen the beat is hysterical / That makes Eric go get Toon the lyrical format is superior / Faces of death JC\'s decaying, cuz they never stayed / The scene of aShe fiend of a rhyme on the mic that you know / It\'s Jelodies-unmakable, pattern-unescapable / A horn if wN bless the child, the earth, the gods and bomb the rOazardous to your health so be friendly / A matter ofThake \'till your clear, make it disappear, make the nNf not, my soul\'ll release! / The scene is recreated,Duz your about to see a disastrous sight / A performaKyrics of fury! A fearified freestyle! / The &quot;R&quot; is iJake sure the system\'s loud when I mention / Phrases ^ou want to hear some sounds that not only pounds butShen nonchalantly tell you what it mean to me / StricFnd I don\'t care if the whole crowd\'s a witness! / I\'Wrogram into the speed of the rhyme, prepare to startJusical madness MC ever made, see it\'s / Now an emergHpen your mind, you will find every word\'ll be / FuriEattle\'s tempting...whatever suits ya! / For words th^ou think you\'re ruffer, then suffer the consequencesN wake ya with hundreds of thousands of volts / Mic-tIovocain ease the pain it might save him / If not, Er^o Rakim, what\'s up? / Yo, I\'m doing the knowledge, EPell, check this out, since Norby Walters is our agenLara Lewis is our agent, word up / Zakia and 4th and Hkay, so who we rollin\' with then? We rollin\' with RuDheck this out, since we talking over / This def beatN wanna hear some of them def rhymes, you know what IShinkin\' of a master plan / \'Cuz ain\'t nuthin\' but swTo I dig into my pocket, all my money is spent / So ITo I start my mission, leave my residence / Thinkin\' N need money, I used to be a stick-up kid / So I thinN used to roll up, this is a hold up, ain\'t nuthin\' fEut now I learned to earn \'cuz I\'m righteous / I feelTearch for a nine to five, if I strive / Then maybe ITo I walk up the street whistlin\' this / Feelin\' out F pen and a paper, a stereo, a tape of / Me and Eric Aish, which is my favorite dish / But without no mone Cuz I don\'t like to dream about gettin\' paid / So I '</code></p>


<div style="border:1px solid #c3e6cb;padding:.75rem 3rem;border-radius:.5rem;font-weight:bold;text-align: center;background-color:#d4edda;color:#155724;border-color:#c3e6cb;">Completed</div>


<h3 id="challenge-21-implement-the-mt19937-mersenne-twister-rng">Challenge 21: Implement the MT19937 Mersenne Twister RNG</h3>
<p><a href="https://cryptopals.com/sets/3/challenges/21">Link</a></p>
<blockquote>
<p>You can get the psuedocode for this from Wikipedia.<br>
If you&rsquo;re writing in Python, Ruby, or (gah) PHP, your language is probably already giving you MT19937 as &ldquo;rand()&quot;; don&rsquo;t use rand(). Write the RNG yourself.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Imports</span>
<span style="color:#f92672">import</span> time
</code></pre></div><p>The <a href="https://stackedit.io/%5Bhttps://en.wikipedia.org/wiki/Mersenne_Twister%5D(https://en.wikipedia.org/wiki/Mersenne_Twister)">Mersenne Twister</a> is a pseudorandom number generator (PRNG). It is by far the most widely used general-purpose PRNG. It&rsquo;s name derives from the fact that its period length is chosen to be a <a href="https://stackedit.io/%5B%5Bhttps://en.wikipedia.org/wiki/Mersenne_prime%5D(https://en.wikipedia.org/wiki/Mersenne_prime)%5D(https://en.wikipedia.org/wiki/Mersenne_Twister)">Mersenne prime</a>.</p>
<p>The implementation is derived from the pseudo-code on Wikipedia. Any of the above links can be used to study more on the topic.</p>
<p><img src="https://hexterisk.github.io/blog/Cryptopals_Set_3/4_image.png" alt="">
<em>Mersenne Twister.</em></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_lowest_bits</span>(n: int, number_of_bits: int) <span style="color:#f92672">-&gt;</span> int:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Returns the lowest &#34;number_of_bits&#34; bits of n.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    mask <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> number_of_bits) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">return</span> n <span style="color:#f92672">&amp;</span>amp;amp;amp;amp;amp;amp; mask

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MT19937</span>:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    This implementation resembles the one of the Wikipedia pseudo-code.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>

    W, N, M, R <span style="color:#f92672">=</span> <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">624</span>, <span style="color:#ae81ff">397</span>, <span style="color:#ae81ff">31</span>
    A <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x9908B0DF</span>
    U, D <span style="color:#f92672">=</span> <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">0xFFFFFFFF</span>
    S, B <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">0x9D2C5680</span>
    T, C <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">0xEFC60000</span>
    L <span style="color:#f92672">=</span> <span style="color:#ae81ff">18</span>
    F <span style="color:#f92672">=</span> <span style="color:#ae81ff">1812433253</span>
    LOWER_MASK <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> R) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
    UPPER_MASK <span style="color:#f92672">=</span> get_lowest_bits(<span style="color:#f92672">not</span> LOWER_MASK, W)
    
    <span style="color:#66d9ef">def</span> __init__(self: object, seed: int):
        self<span style="color:#f92672">.</span>mt <span style="color:#f92672">=</span> []

        self<span style="color:#f92672">.</span>index <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>N
        self<span style="color:#f92672">.</span>mt<span style="color:#f92672">.</span>append(seed)
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, self<span style="color:#f92672">.</span>index):
            self<span style="color:#f92672">.</span>mt<span style="color:#f92672">.</span>append(get_lowest_bits(self<span style="color:#f92672">.</span>F <span style="color:#f92672">*</span> (self<span style="color:#f92672">.</span>mt[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">^</span> (self<span style="color:#f92672">.</span>mt[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;&gt;</span> (self<span style="color:#f92672">.</span>W <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>))) <span style="color:#f92672">+</span> i, self<span style="color:#f92672">.</span>W))
            
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">extract_number</span>(self: object) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Extracts the new random number.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>index <span style="color:#f92672">&gt;=</span> self<span style="color:#f92672">.</span>N:
            self<span style="color:#f92672">.</span>twist()

        y <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>mt[self<span style="color:#f92672">.</span>index]
        y <span style="color:#f92672">^=</span> (y <span style="color:#f92672">&gt;&gt;</span> self<span style="color:#f92672">.</span>U) <span style="color:#f92672">&amp;</span>amp;amp;amp;amp;amp;amp; self<span style="color:#f92672">.</span>D
        y <span style="color:#f92672">^=</span> (y <span style="color:#f92672">&lt;&lt;</span> self<span style="color:#f92672">.</span>S) <span style="color:#f92672">&amp;</span>amp;amp;amp;amp;amp;amp; self<span style="color:#f92672">.</span>B
        y <span style="color:#f92672">^=</span> (y <span style="color:#f92672">&lt;&lt;</span> self<span style="color:#f92672">.</span>T) <span style="color:#f92672">&amp;</span>amp;amp;amp;amp;amp;amp; self<span style="color:#f92672">.</span>C
        y <span style="color:#f92672">^=</span> (y <span style="color:#f92672">&gt;&gt;</span> self<span style="color:#f92672">.</span>L)

        self<span style="color:#f92672">.</span>index <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> get_lowest_bits(y, self<span style="color:#f92672">.</span>W)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">twist</span>(self: object):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Performs the twisting part of the encryption.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>N):
            x <span style="color:#f92672">=</span> (self<span style="color:#f92672">.</span>mt[i] <span style="color:#f92672">&amp;</span>amp;amp;amp;amp;amp;amp; self<span style="color:#f92672">.</span>UPPER_MASK) <span style="color:#f92672">+</span> (self<span style="color:#f92672">.</span>mt[(i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> self<span style="color:#f92672">.</span>N] <span style="color:#f92672">&amp;</span>amp;amp;amp;amp;amp;amp; self<span style="color:#f92672">.</span>LOWER_MASK)
            x_a <span style="color:#f92672">=</span> x <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">if</span> x <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
                x_a <span style="color:#f92672">^=</span> self<span style="color:#f92672">.</span>A

            self<span style="color:#f92672">.</span>mt[i] <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>mt[(i <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>M) <span style="color:#f92672">%</span> self<span style="color:#f92672">.</span>N] <span style="color:#f92672">^</span> x_a

        self<span style="color:#f92672">.</span>index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Check if the numbers look random</span>
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10</span>):
    <span style="color:#66d9ef">print</span>(MT19937(i)<span style="color:#f92672">.</span>extract_number())
</code></pre></div><p><code>2357136044</code><br>
<code>1791095845</code><br>
<code>1872583848</code><br>
<code>2365658986</code><br>
<code>4153361530</code><br>
<code>953453411</code><br>
<code>3834805130</code><br>
<code>327741615</code><br>
<code>3751350723</code><br>
<code>44556670</code></p>


<div style="border:1px solid #c3e6cb;padding:.75rem 3rem;border-radius:.5rem;font-weight:bold;text-align: center;background-color:#d4edda;color:#155724;border-color:#c3e6cb;">Completed</div>


<h3 id="challenge-22-crack-an-mt19937-seed">Challenge 22: Crack an MT19937 seed</h3>
<p><a href="https://cryptopals.com/sets/3/challenges/22">Link</a></p>
<blockquote>
<p>Make sure your MT19937 accepts an integer seed value. Test it (verify that you&rsquo;re getting the same sequence of outputs given a seed).<br>
Write a routine that performs the following operation:</p>
<ol>
<li>Wait a random number of seconds between, I don&rsquo;t know, 40 and 1000.</li>
<li>Seeds the RNG with the current Unix timestamp.</li>
<li>Waits a random number of seconds again.</li>
<li>Returns the first 32 bit output of the RNG.</li>
</ol>
<p>You get the idea. Go get coffee while it runs. Or just simulate the passage of time, although you&rsquo;re missing some of the fun of this exercise if you do that.<br>
From the 32 bit RNG output, discover the seed.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">    <span style="color:#75715e"># Imports</span>
    <span style="color:#f92672">import</span> time
    <span style="color:#f92672">import</span> random
</code></pre></div><p>The point of this function is to generate a time-based seed, but to throw off the attacker by executing a <code>sleep</code> for a random time before generating the seed and again for a random time after generating it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">MT19937_timestamp_seed</span>() <span style="color:#f92672">-&gt;</span> (int, int):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Generates a timestamp based seed for MT19937.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    
    <span style="color:#75715e"># Sleeps for a random time to generate a random seed.</span>
    time<span style="color:#f92672">.</span>sleep(random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">40</span>, <span style="color:#ae81ff">100</span>))
    seed <span style="color:#f92672">=</span> int(time<span style="color:#f92672">.</span>time())
    
    <span style="color:#75715e"># Initialises the object with the generated seed.</span>
    mt_rng <span style="color:#f92672">=</span> MT19937(seed)
    
    <span style="color:#75715e"># Sleep for a random time to throw off the attacker.</span>
    time<span style="color:#f92672">.</span>sleep(random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">40</span>, <span style="color:#ae81ff">100</span>))
    <span style="color:#66d9ef">return</span> mt_rng<span style="color:#f92672">.</span>extract_number(), seed
</code></pre></div><p>We brute force the seed value by approximating the maximum time spent between generation of the seed and the value returned to us (I took it to be 200), </p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">break_MT19937_seed</span>(rng_function: callable) <span style="color:#f92672">-&gt;</span> int:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Breaks the MT19937 seed value.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    
    random_number, real_seed <span style="color:#f92672">=</span> rng_function()
    
    <span style="color:#75715e"># Note current time to start backtracking by the millisecond.</span>
    now <span style="color:#f92672">=</span> int(time<span style="color:#f92672">.</span>time())
    
    <span style="color:#75715e"># Assuming 200 seconds to be the maximum time between generation of seed and us receiving it.</span>
    before <span style="color:#f92672">=</span> now <span style="color:#f92672">-</span> <span style="color:#ae81ff">200</span>
    <span style="color:#75715e"># Brtue force with the value of seed between the set time frame.</span>
    <span style="color:#66d9ef">for</span> seed <span style="color:#f92672">in</span> range(before, now):
        rng <span style="color:#f92672">=</span> MT19937(seed)
        number <span style="color:#f92672">=</span> rng<span style="color:#f92672">.</span>extract_number()
        <span style="color:#66d9ef">if</span> number <span style="color:#f92672">==</span> random_number:
            <span style="color:#66d9ef">return</span> seed

number <span style="color:#f92672">=</span> break_MT19937_seed(MT19937_timestamp_seed)
</code></pre></div>

<div style="border:1px solid #c3e6cb;padding:.75rem 3rem;border-radius:.5rem;font-weight:bold;text-align: center;background-color:#d4edda;color:#155724;border-color:#c3e6cb;">Completed</div>


<h3 id="challenge-23-clone-an-mt19937-rng-from-its-output">Challenge 23: Clone an MT19937 RNG from its output</h3>
<p><a href="https://cryptopals.com/sets/3/challenges/23">Link</a></p>
<blockquote>
<p>The internal state of MT19937 consists of 624 32 bit integers.<br>
For each batch of 624 outputs, MT permutes that internal state. By permuting state regularly, MT19937 achieves a period of 2**19937, which is Big.<br>
Each time MT19937 is tapped, an element of its internal state is subjected to a tempering function that diffuses bits through the result.<br>
The tempering function is invertible; you can write an &ldquo;untemper&rdquo; function that takes an MT19937 output and transforms it back into the corresponding element of the MT19937 state array.<br>
To invert the temper transform, apply the inverse of each of the operations in the temper transform in reverse order. There are two kinds of operations in the temper transform each applied twice; one is an XOR against a right-shifted value, and the other is an XOR against a left-shifted value AND&rsquo;d with a magic number. So you&rsquo;ll need code to invert the &ldquo;right&rdquo; and the &ldquo;left&rdquo; operation.<br>
Once you have &ldquo;untemper&rdquo; working, create a new MT19937 generator, tap it for 624 outputs, untemper each of them to recreate the state of the generator, and splice that state into a new instance of the MT19937 generator.<br>
The new &ldquo;spliced&rdquo; generator should predict the values of the original.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Imports</span>
<span style="color:#f92672">import</span> time
<span style="color:#f92672">import</span> random
</code></pre></div><p>The major ground work to be done here is to reverse the temper function, that is, to create an “untempering” function. Since the question tells us that the tempering function is invertible, writing such a function is possible. Have a go at it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">int_to_bit_list</span>(x: int) <span style="color:#f92672">-&gt;</span> list:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Convert an integer to it&#39;s binary form, and return the bits in a list.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#66d9ef">return</span> [int(b) <span style="color:#66d9ef">for</span> b <span style="color:#f92672">in</span> <span style="color:#e6db74">&#34;{:032b}&#34;</span><span style="color:#f92672">.</span>format(x)]

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bit_list_to_int</span>(l: list) <span style="color:#f92672">-&gt;</span> int:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Receive a list of bits and convert it into an integer.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#66d9ef">return</span> int(<span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(str(x) <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> l), base<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">invert_shift_mask_xor</span>(y: int, direction: str, shift: int, mask<span style="color:#f92672">=</span><span style="color:#ae81ff">0xFFFFFFFF</span>) <span style="color:#f92672">-&gt;</span> int:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Shift, mask and xor the given integer in the specified direction with the passed mask.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    y <span style="color:#f92672">=</span> int_to_bit_list(y)
    mask <span style="color:#f92672">=</span> int_to_bit_list(mask)

    <span style="color:#66d9ef">if</span> direction <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;left&#34;</span>:
        y<span style="color:#f92672">.</span>reverse()
        mask<span style="color:#f92672">.</span>reverse()
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">assert</span> direction <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;right&#34;</span>

    x <span style="color:#f92672">=</span> [None]<span style="color:#f92672">*</span><span style="color:#ae81ff">32</span>
    <span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">32</span>):
        <span style="color:#66d9ef">if</span> n <span style="color:#f92672">&lt;</span> shift:
            x[n] <span style="color:#f92672">=</span> y[n]
        <span style="color:#66d9ef">else</span>:
            x[n] <span style="color:#f92672">=</span> y[n] <span style="color:#f92672">^</span> (mask[n] <span style="color:#f92672">&amp;</span>amp;amp;amp;amp;amp;amp; x[n<span style="color:#f92672">-</span>shift])

    <span style="color:#66d9ef">if</span> direction <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;left&#39;</span>:
        x<span style="color:#f92672">.</span>reverse()

    <span style="color:#66d9ef">return</span> bit_list_to_int(x)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">untemper</span>(y: int) <span style="color:#f92672">-&gt;</span> int:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Reverses the temper part of the Mersenne Twister.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    (w, n, m, r) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">624</span>, <span style="color:#ae81ff">397</span>, <span style="color:#ae81ff">31</span>)
    a <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x9908B0DF</span>
    (u, d) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">0xFFFFFFFF</span>)
    (s, b) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">0x9D2C5680</span>)
    (t, c) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">0xEFC60000</span>)
    l <span style="color:#f92672">=</span> <span style="color:#ae81ff">18</span>
    f <span style="color:#f92672">=</span> <span style="color:#ae81ff">1812433253</span>

    xx <span style="color:#f92672">=</span> y
    xx <span style="color:#f92672">=</span> invert_shift_mask_xor(xx, direction<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;right&#39;</span>, shift<span style="color:#f92672">=</span>l)
    xx <span style="color:#f92672">=</span> invert_shift_mask_xor(xx, direction<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;left&#39;</span>, shift<span style="color:#f92672">=</span>t, mask<span style="color:#f92672">=</span>c)
    xx <span style="color:#f92672">=</span> invert_shift_mask_xor(xx, direction<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;left&#39;</span>, shift<span style="color:#f92672">=</span>s, mask<span style="color:#f92672">=</span>b)
    xx <span style="color:#f92672">=</span> invert_shift_mask_xor(xx, direction<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;right&#39;</span>, shift<span style="color:#f92672">=</span>u, mask<span style="color:#f92672">=</span>d)

    <span style="color:#66d9ef">return</span> xx
</code></pre></div><p>Once the “untempering” function is setup, the MT19937 generator can be tapped into for it&rsquo;s current state, saved in the form of 624 outputs. This state can be used to initialise a new generatorm which can therefore predict the outputs of the current one, since it&rsquo;s figuratively stepping in the original generator&rsquo;s shoes by replicating it&rsquo;s state.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_cloned_rng</span>(original_rng: callable) <span style="color:#f92672">-&gt;</span> callable:
    <span style="color:#e6db74">&#34;&#34;&#34;Taps the given rng for 624 outputs, untempers each of them to recreate the state of the generator,
</span><span style="color:#e6db74">    and splices that state into a new &#34;cloned&#34; instance of the MT19937 generator.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    mt <span style="color:#f92672">=</span> []

    <span style="color:#75715e"># Recreate the state mt of original_rng.</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(MT19937<span style="color:#f92672">.</span>N):
        mt<span style="color:#f92672">.</span>append(untemper(original_rng<span style="color:#f92672">.</span>extract_number()))

    <span style="color:#75715e"># Create a new generator and set it to have the same state.</span>
    cloned_rng <span style="color:#f92672">=</span> MT19937(<span style="color:#ae81ff">0</span>)
    cloned_rng<span style="color:#f92672">.</span>mt <span style="color:#f92672">=</span> mt

    <span style="color:#66d9ef">return</span> cloned_rng
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">seed <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">32</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
rng <span style="color:#f92672">=</span> MT19937(seed)
cloned_rng <span style="color:#f92672">=</span> get_cloned_rng(rng)

<span style="color:#75715e"># Check that the two PRNGs produce the same output.</span>
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">99</span>):
    <span style="color:#66d9ef">if</span> rng<span style="color:#f92672">.</span>extract_number() <span style="color:#f92672">!=</span> cloned_rng<span style="color:#f92672">.</span>extract_number():
        test(rng<span style="color:#f92672">.</span>extract_number() <span style="color:#f92672">==</span> <span style="color:#66d9ef">print</span>(cloned_rng<span style="color:#f92672">.</span>extract_number()))
</code></pre></div>

<div style="border:1px solid #c3e6cb;padding:.75rem 3rem;border-radius:.5rem;font-weight:bold;text-align: center;background-color:#d4edda;color:#155724;border-color:#c3e6cb;">Completed</div>


<h3 id="challenge-24-create-the-mt19937-stream-cipher-and-break-it">Challenge 24: Create the MT19937 stream cipher and break it</h3>
<p><a href="https://cryptopals.com/sets/3/challenges/24">Link</a></p>
<blockquote>
<p>You can create a trivial stream cipher out of any PRNG; use it to generate a sequence of 8 bit outputs and call those outputs a keystream. XOR each byte of plaintext with each successive byte of keystream.<br>
Write the function that does this for MT19937 using a 16-bit seed. Verify that you can encrypt and decrypt properly. This code should look similar to your CTR code.<br>
Use your function to encrypt a known plaintext (say, 14 consecutive &lsquo;A&rsquo; characters) prefixed by a random number of random characters.<br>
From the ciphertext, recover the &ldquo;key&rdquo; (the 16 bit seed).<br>
Use the same idea to generate a random &ldquo;password reset token&rdquo; using MT19937 seeded from the current time.<br>
Write a function to check if any given password token is actually the product of an MT19937 PRNG seeded with the current time.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Imports</span>
<span style="color:#f92672">import</span> os
<span style="color:#f92672">import</span> time
<span style="color:#f92672">import</span> math
<span style="color:#f92672">import</span> random
</code></pre></div><p>The function mentioned in question to generate a keystream out of a 16-bit seed fed MT19937 generator.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">MT19937_keystream_generator</span>(seed: int) <span style="color:#f92672">-&gt;</span> bytes:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Generate keystream for MT19937
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#75715e"># Verify that the seed is atmost 16 bit long.</span>
    <span style="color:#66d9ef">assert</span> math<span style="color:#f92672">.</span>log2(seed) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">16</span>
    
    prng <span style="color:#f92672">=</span> MT19937(seed)
    <span style="color:#66d9ef">while</span> True:
        number <span style="color:#f92672">=</span> prng<span style="color:#f92672">.</span>extract_number()
        <span style="color:#66d9ef">yield</span> <span style="color:#f92672">from</span> number.to_bytes(<span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#34;big&#34;</span>)
</code></pre></div><p>The function to encrypt a given string via a MT19937 generated keystream.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">MT19937_CTR</span>(string: str, seed: int) <span style="color:#f92672">-&gt;</span> bytes:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Encrypts a plaintext with MT19937 CTR Mode.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#75715e"># Verify that the seed is an integer.</span>
    <span style="color:#66d9ef">assert</span> isinstance(seed, int)
    
    keystream <span style="color:#f92672">=</span> MT19937_keystream_generator(seed)
    <span style="color:#66d9ef">if</span> len(string) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">return</span> bytes([(b1 <span style="color:#f92672">^</span> b2) <span style="color:#66d9ef">for</span> b1, b2 <span style="color:#f92672">in</span> zip(string, keystream)])

plaintext <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello World!&#34;</span>

<span style="color:#75715e"># Append random characters before plainttext.</span>
string <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
<span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>)):
    i <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">33</span>, <span style="color:#ae81ff">126</span>)
    string <span style="color:#f92672">+=</span> chr(i)<span style="color:#f92672">.</span>encode()
string <span style="color:#f92672">+=</span> plaintext<span style="color:#f92672">.</span>encode()

seed <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">16</span>)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;&gt; Seed value coded to be&#34;</span>, seed)
cipher_bytes <span style="color:#f92672">=</span> MT19937_CTR(string, seed)
deciphered_bytes <span style="color:#f92672">=</span> MT19937_CTR(cipher_bytes, seed)

<span style="color:#75715e"># Verify if it can be decrypted.</span>
<span style="color:#66d9ef">assert</span> string <span style="color:#f92672">==</span> deciphered_bytes

<span style="color:#75715e"># A 16 bit key makes it easy to brute force the key.</span>
<span style="color:#66d9ef">for</span> seed <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">16</span>):
    deciphered_bytes <span style="color:#f92672">=</span> MT19937_CTR(cipher_bytes, seed)
    <span style="color:#66d9ef">try</span>:
        <span style="color:#66d9ef">assert</span> string <span style="color:#f92672">==</span> deciphered_bytes
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;&gt; Brute force successful.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Seed:&#34;</span>, seed)
        test(True)
        <span style="color:#66d9ef">break</span>
    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">AssertionError</span>:
        <span style="color:#66d9ef">continue</span>
</code></pre></div><p><code>&gt; Seed value coded to be 41129</code><br>
<code>&gt; Brute force successful.</code><br>
<code>Seed: 41129</code></p>


<div style="border:1px solid #c3e6cb;padding:.75rem 3rem;border-radius:.5rem;font-weight:bold;text-align: center;background-color:#d4edda;color:#155724;border-color:#c3e6cb;">Completed</div>



            </div>
        </article>

        <hr />

        <div class="post-info">
                <p>
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://hexterisk.github.io/blog/tags/matasano">Matasano</a></span><span class="tag"><a href="https://hexterisk.github.io/blog/tags/cryptography">cryptography</a></span><span class="tag"><a href="https://hexterisk.github.io/blog/tags/aes">AES</a></span><span class="tag"><a href="https://hexterisk.github.io/blog/tags/ecb">ECB</a></span><span class="tag"><a href="https://hexterisk.github.io/blog/tags/cbc">CBC</a></span><span class="tag"><a href="https://hexterisk.github.io/blog/tags/ctr">CTR</a></span><span class="tag"><a href="https://hexterisk.github.io/blog/tags/xor">xor</a></span><span class="tag"><a href="https://hexterisk.github.io/blog/tags/mt19937">MT19937</a></span><span class="tag"><a href="https://hexterisk.github.io/blog/tags/mersenne">Mersenne</a></span><span class="tag"><a href="https://hexterisk.github.io/blog/tags/prng">PRNG</a></span><span class="tag"><a href="https://hexterisk.github.io/blog/tags/seed">seed</a></span>
                </p>

            <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>4883 Words</p>

            <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2020-03-23 05:30 &#43;0530</p>
        </div>

        
            <div class="pagination">
                <div class="pagination__title">
                    <span class="pagination__title-h"></span>
                    <hr />
                </div>

                <div class="pagination__buttons">
                    
                        <span class="button previous">
                            <a href="https://hexterisk.github.io/blog/posts/2020/03/27/set-4/">
                                <span class="button__icon">←</span>
                                <span class="button__text">Set 4</span>
                            </a>
                        </span>
                    

                    
                        <span class="button next">
                            <a href="https://hexterisk.github.io/blog/posts/2020/03/21/set-2/">
                                <span class="button__text">Set 2</span>
                                <span class="button__icon">→</span>
                            </a>
                        </span>
                    
                </div>
            </div>
        

        
    </main>

            </div>

            
                <footer class="footer">
    
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">rhazdon</a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content" style="margin-bottom: -0.8rem;">
            <span><a style="text-decoration: none;"> .</a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span><a style="text-decoration: none;" style="font-size: 1.4rem; margin-bottom: -1.0rem;">..:</a></span>
        </div>
    </div>
</footer>
            
        </div>

        




<script type="text/javascript" src="https://hexterisk.github.io/blog/bundle.min.08ccaf9cef8b4e0ebd0b0158e66a7bfc0ddbb2194cdb0099e8814ddb89cc7628b27b1158846564e6e03d9ffc5f4d1bc7dfc274d359f9408d1c63d73a3f7332e9.js" integrity="sha512-CMyvnO&#43;LTg69CwFY5mp7/A3bshlM2wCZ6IFN24nMdiiyexFYhGVk5uA9n/xfTRvH38J001n5QI0cY9c6P3My6Q=="></script>



    </body>
</html>
